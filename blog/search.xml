<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[22222]]></title>
    <url>%2Fblog%2F2018%2F09%2F04%2F22222%2F</url>
    <content type="text"><![CDATA[大大方方发大发大发 复活节风格会飞的凤凰法国红酒国防部克服困难 3338]]></content>
      <categories>
        <category>333333</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写给大家看的设计书-3]]></title>
    <url>%2Fblog%2F2018%2F08%2F28%2F%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[一、设计原则第一章四大基本原则元素：字体、颜色、大小、线宽、形状、空间等 - 对比：避免过于相似，让元素截然不同- 重复：视觉要素重复出现，增加条理性，加强统一性- 对齐：不随意放置元素位置，元素间建立视觉联系- 亲密性：彼此相关项归组，形成视觉单元##### 第二章 亲密性亲密性原则：组织、归组相关项，亲密性/紧密性（物理位置接近）意味着存在关联相关元素通过组织、归组，建立元素单元能够使页面更具条理性、逻辑性。并增强可读性，正确引导用户理解内容。1）方法：理解元素间内容关系，根据内容关系调整元素（文字、图片）大小、间距、位置，并保持适当的留白2）小结：相关项元素根据亲密性原则形成视觉单元，有意识地引导用户的阅读路径。①.根本目的：实现组织性②.如何实现：③.避免：都是淡淡的 第三章 对比第四章 重复第五章 对比]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H&L-HRMs项目总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F28%2FH%26L-HRMs%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[返校-Detention]]></title>
    <url>%2Fblog%2F2018%2F08%2F27%2F%E8%BF%94%E6%A0%A1%2F</url>
    <content type="text"><![CDATA[序章魏仲延视角： 游戏开篇是课堂上老师讲课，后来有个叫白国峰的向殷老师询问是否见过一张书单。主角在课堂睡着了，醒来发现教室空无一人，黑板上写着“台风警报，请同学尽速返家”通过主角反应，我们知道这个季节有台风是件不寻常的事。主角后桌上有张纸条，是询问殷老师请假事宜，收录在周记本里 主角教室在2楼左边第一间教室窗台拾取一张纸条：大榕树下的速写，主角所在班级：二年仁班，二层只有两个班级 一楼，公告栏：检举匪谍公报公告栏旁是老高住所、工具间工具间取得：弯曲手柄、工具间墙壁：金刚般若波罗蜜经手摇柄打开铁卷门左走水仙花下取得：旧照片一楼最左：校长室穿过礼堂离开学校 礼堂讲台上有个女生礼堂库房拾取雨伞，通风口勾取白鹿项链学校外桥断了，河里变成大量血水女生是三年忠班的方芮欣魏仲延去整理过夜装备，切换到方芮欣视角，魏仲延倒吊在礼堂，取得魏仲延周记本，礼堂外小庙取得礼堂钥匙和一张魍魉图：”夜晚出入请小心，遇见魍魉莫害怕，屏住呼吸慢慢行“回礼堂的路上遇到魍魉，礼堂储存室里拾得纸条，读书会：老师聚集学生私下教授管制书籍校长室传来电话铃声。”方同学，我在辅导室等你。“一二年级来工具间搬东西，会想起讨厌的事二楼仁班，黑板“自求多福”，后门宣传栏取得“校内禁止博弈”，女厕取得“钳子””骰子“镜子“忘记了，还是不愿想起来”回去路上遇到魍魉，回到二年仁班，钳子打开铁门，保健室门口，取得“魍魉脚尾饭”图。进入保健室，灯箱下取得卫生库房钥匙，获得脚尾饭，获得黄敏昌诊断书，神坛存档。出门放置脚尾饭，吸引魍魉，屏息，用钥匙打开卫生库。洗眼器获得骰子，铁箱获得松香水回保健室获取脚尾饭，引开魍魉。一楼用松香水喷洗门上的符咒，获取刀片，获取骰子，三颗骰子掷入盆内，获取点数623，获得割喉图回到礼堂，割开魏仲延喉咙，用碗盛血，回到三楼，用血看清刻痕，周记本拓印，到一楼根据图示开锁上楼，铁门内是辅导室，进去前到隔壁教室存档。]]></content>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H&L-Xpress项目总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F24%2FH%26L-Xpress%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目背景H&amp;L Supermarket（以下简称“H&amp;L”）是马来西亚砂拉越最大、最受欢迎的零售连锁超市之一。拥有超过10家分店，服务于古晋市和塞尔维亚各地大众消费者。 项目简介2016年接触并执行马来西亚零售商H&amp;L的开发项目，直至2018年7月份项目才陆续收尾告一段落。项目前期主要负责界面视觉设计部分，后期因团队人员变动同时接手了项目的需求整理及产品设计。]]></content>
      <tags>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《设计心理学》]]></title>
    <url>%2Fblog%2F2018%2F08%2F24%2F%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[唐纳德∙A∙诺曼：美国认知心理学家、计算机工程师、工业设计家，认知科学学会发起人之一。尼尔森诺曼集团（NNG）创办人之一。 序 以用户为中心的设计是避免犯错的一个根本途径 作者在序言中提出一个观点：“知识不仅储存于人脑，还储存于客观世界。”当用户在使用一件物品时遇到麻烦，并非用户的责任，而是属于技术性（设计）问题。 设计必须反映产品的核心功能、工作原理、可能的操作方法（功能可供性？），以及反馈产品在某一特定时刻的运转状态。 第一章-日用品中的设计问题在日常场景中，用户时常困扰于无法完全理解和使用产品。某些产品需要用户付出较高的学习成本。例如令人迷惑的卡洛曼壶、功能复杂的电器等。 人脑设计精妙，只需一丝线索人脑便可立即工作，对外部世界进行解释和理解。而优秀的产品能为用户提供操作方法的线索，使用户容易理解。反之，拙劣的产品难以使用，令人沮丧。而用户不应该在使用日常产品时感到困惑。 可视性设计中一项重要原则。 正确操作部位必须显而易见，并能传达正确信息。 以“门”为例，我们知道门无非“开”和“关”两个动作，那么接下来就要思考的是如何完成这两个动作。思考两个基本问题： 1.开门方向 2.用户用力方向 了解基本问题后，那么设计师可能用：推、拉、滑动或组合动作等方式去解决开门这个问题。在解决问题的过程中，应该注意： 1.使自然信号能被用户直接感知（对自然信号的使用--“自然设计”），而无须文字、符号加以说明； 2.避免用户反复出错和试验； 3.设计中不应该只考虑“美观性”而忽略“适用性”。 关于用户操作意图和可能的操作方法之间的匹配 这里作者举了三个例子： 1.一个按钮被赋予两种功能的投影仪； 2.技术员操作过程中无法看见升降屏幕高度； 3.学习成本高而导致被忽略的“暂停键”。 说明了三个问题： 1.说明欠佳，新功能无法与用户已熟知的功能产生联系； 2.操作缺乏可视性； 3.用户无法感知操作结果。 日常生活中设备功能越来越多，用户往往因为看不懂说明而手足无措，仅记住了一两个基本操作。如何解决问题： 1.使用户能直观感受到机器运转以及与机器的互动（用户操作能得到即时反馈）； 2.使用户感知到物品（或者功能）之间关键差异； 3.适度注重可视性 1.使用户能直观感受到机器运转以及与机器的互动（用户操作能得到即时反馈）； 2.使用户感知到物品（或者功能）之间关键差异； 3.适度注重可视性]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>UX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript有用的代码片段和trick]]></title>
    <url>%2Fblog%2F2018%2F08%2F22%2FJavaScript%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8Ctrick%2F</url>
    <content type="text"><![CDATA[浮点数取整12345const x = 123.4545;x &gt;&gt; 0; // 123~~x; // 123x | 0; // 123Math.floor(x); // 123 注意：前三种方法只适用于32个位整数，对于负数的处理上和 Math.floor是不同的。 12Math.floor(-12.53); // -13-12.53 | 0; // -12 生成6位数字验证码1234567891011// 方法一('000000' + Math.floor(Math.random() * 999999)).slice(-6);// 方法二Math.random().toString().slice(-6);// 方法三Math.random().toFixed(6).slice(-6);// 方法四'' + Math.floor(Math.random() * 999999); 16进制颜色代码生成1234(function() &#123; return '#'+('00000'+ (Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6);&#125;)(); 驼峰命名转下划线1'componentMapModelRegistry'.match(/^[a-z][a-z0-9]+|[A-Z][a-z0-9]*/g).join('_').toLowerCase(); // component_map_model_registry url查询参数转json格式12345678910111213141516171819// ES6const query = (search = '') =&gt; ((querystring = '') =&gt; (q =&gt; (querystring.split('&amp;').forEach(item =&gt; (kv =&gt; kv[0] &amp;&amp; (q[kv[0]] = kv[1]))(item.split('='))), q))(&#123;&#125;))(search.split('?')[1]);// 对应ES5实现var query = function(search) &#123; if (search === void 0) &#123; search = ''; &#125; return (function(querystring) &#123; if (querystring === void 0) &#123; querystring = ''; &#125; return (function(q) &#123; return (querystring.split('&amp;').forEach(function(item) &#123; return (function(kv) &#123; return kv[0] &amp;&amp; (q[kv[0]] = kv[1]); &#125;)(item.split('=')); &#125;), q); &#125;)(&#123;&#125;); &#125;)(search.split('?')[1]);&#125;;query('?key1=value1&amp;key2=value2'); // es6.html:14 &#123;key1: "value1", key2: "value2"&#125; 获取URL参数12345678function getQueryString(key)&#123; var reg = new RegExp("(^|&amp;)"+ key +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(!!r)&#123; return unescape(r[2]); &#125; return null;&#125; n维数组展开成一维数组1234567891011121314151617181920212223242526var foo = [1, [2, 3], ['4', 5, ['6',7,[8]]], [9], 10];// 方法一// 限制：数组项不能出现`,`，同时数组项全部变成了字符数字foo.toString().split(','); // ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]// 方法二// 转换后数组项全部变成数字了eval('[' + foo + ']'); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 方法三，使用ES6展开操作符// 写法太过麻烦，太过死板[1, ...[2, 3], ...['4', 5, ...['6',7,...[8]]], ...[9], 10]; // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法四JSON.parse(`[$&#123;JSON.stringify(foo).replace(/\[|]/g, '')&#125;]`); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法五const flatten = (ary) =&gt; ary.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法六function flatten(a) &#123; return Array.isArray(a) ? [].concat(...a.map(flatten)) : a;&#125;flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10] 注：更多方法请参考《How to flatten nested array in JavaScript?》 日期格式化12345678910111213141516171819202122232425262728293031323334353637383940// 方法一function format1(x, y) &#123; var z = &#123; y: x.getFullYear(), M: x.getMonth() + 1, d: x.getDate(), h: x.getHours(), m: x.getMinutes(), s: x.getSeconds() &#125;; return y.replace(/(y+|M+|d+|h+|m+|s+)/g, function(v) &#123; return ((v.length &gt; 1 ? "0" : "") + eval('z.' + v.slice(-1))).slice(-(v.length &gt; 2 ? v.length : 2)) &#125;);&#125;format1(new Date(), 'yy-M-d h:m:s'); // 17-10-14 22:14:41// 方法二Date.prototype.format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); &#125; for (var k in o)&#123; if (new RegExp("(" + k + ")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); &#125; &#125; return fmt;&#125;new Date().format('yy-M-d h:m:s'); // 17-10-14 22:18:17 统计文字个数1234567891011121314151617function wordCount(data) &#123; var pattern = /[a-zA-Z0-9_\u0392-\u03c9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g; var m = data.match(pattern); var count = 0; if( m === null ) return count; for (var i = 0; i &lt; m.length; i++) &#123; if (m[i].charCodeAt(0) &gt;= 0x4E00) &#123; count += m[i].length; &#125; else &#123; count += 1; &#125; &#125; return count;&#125;var text = '贷款买房，也意味着你能给自己的资产加杠杆，能够撬动更多的钱，来孳生更多的财务性收入。';wordCount(text); // 38 特殊字符转义123456function htmlspecialchars (str) &#123; var str = str.toString().replace(/&amp;/g, "&amp;amp;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/"/g, '&amp;quot;'); return str;&#125;htmlspecialchars('&amp;jfkds&lt;&gt;'); // "&amp;amp;jfkds&amp;lt;&amp;gt;" 动态插入js123456789function injectScript(src) &#123; var s, t; s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = src; t = document.getElementsByTagName('script')[0]; t.parentNode.insertBefore(s, t);&#125; 格式化数量123456789101112131415161718192021222324// 方法一function formatNum (num, n) &#123; if (typeof num == "number") &#123; num = String(num.toFixed(n || 0)); var re = /(-?\d+)(\d&#123;3&#125;)/; while (re.test(num)) num = num.replace(re, "$1,$2"); return num; &#125; return num;&#125;formatNum(2313123, 3); // "2,313,123.000"// 方法二'2313123'.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ','); // "2,313,123"// 方法三function formatNum(str) &#123; return str.split('').reverse().reduce((prev, next, index) =&gt; &#123; return ((index % 3) ? next : (next + ',')) + prev &#125;);&#125;formatNum('2313323'); // "2,313,323" 身份证验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function chechCHNCardId(sNo) &#123; if (!this.regExpTest(sNo, /^[0-9]&#123;17&#125;[X0-9]$/)) &#123; return false; &#125; sNo = sNo.toString(); var a, b, c; a = parseInt(sNo.substr(0, 1)) * 7 + parseInt(sNo.substr(1, 1)) * 9 + parseInt(sNo.substr(2, 1)) * 10; a = a + parseInt(sNo.substr(3, 1)) * 5 + parseInt(sNo.substr(4, 1)) * 8 + parseInt(sNo.substr(5, 1)) * 4; a = a + parseInt(sNo.substr(6, 1)) * 2 + parseInt(sNo.substr(7, 1)) * 1 + parseInt(sNo.substr(8, 1)) * 6; a = a + parseInt(sNo.substr(9, 1)) * 3 + parseInt(sNo.substr(10, 1)) * 7 + parseInt(sNo.substr(11, 1)) * 9; a = a + parseInt(sNo.substr(12, 1)) * 10 + parseInt(sNo.substr(13, 1)) * 5 + parseInt(sNo.substr(14, 1)) * 8; a = a + parseInt(sNo.substr(15, 1)) * 4 + parseInt(sNo.substr(16, 1)) * 2; b = a % 11; if (b == 2) &#123; c = sNo.substr(17, 1).toUpperCase(); &#125; else &#123; c = parseInt(sNo.substr(17, 1)); &#125; switch (b) &#123; case 0: if (c != 1) &#123; return false; &#125; break; case 1: if (c != 0) &#123; return false; &#125; break; case 2: if (c != "X") &#123; return false; &#125; break; case 3: if (c != 9) &#123; return false; &#125; break; case 4: if (c != 8) &#123; return false; &#125; break; case 5: if (c != 7) &#123; return false; &#125; break; case 6: if (c != 6) &#123; return false; &#125; break; case 7: if (c != 5) &#123; return false; &#125; break; case 8: if (c != 4) &#123; return false; &#125; break; case 9: if (c != 3) &#123; return false; &#125; break; case 10: if (c != 2) &#123; return false; &#125;; &#125; return true;&#125; 测试质数123function isPrime(n) &#123; return !(/^.?$|^(..+?)\1+$/).test('1'.repeat(n))&#125; 统计字符串中相同字符出现的次数1234567var arr = 'abcdaabc';var info = arr .split('') .reduce((p, k) =&gt; (p[k]++ || (p[k] = 1), p), &#123;&#125;);console.log(info); //&#123; a: 3, b: 2, c: 2, d: 1 &#125; 使用void 0来解决undefined被污染问题123undefined = 1;!!undefined; // true!!void(0); // false 单行写一个评级组件1"★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate); JavaScript 错误处理的方式的正确姿势1234567try &#123; something&#125; catch (e) &#123; window.location.href = "http://stackoverflow.com/search?q=[js]+" + e.message;&#125; 匿名函数自执行写法1234567891011121314151617181920( function() &#123;&#125;() );( function() &#123;&#125; )();[ function() &#123;&#125;() ];~ function() &#123;&#125;();! function() &#123;&#125;();+ function() &#123;&#125;();- function() &#123;&#125;();delete function() &#123;&#125;();typeof function() &#123;&#125;();void function() &#123;&#125;();new function() &#123;&#125;();new function() &#123;&#125;;var f = function() &#123;&#125;();1, function() &#123;&#125;();1 ^ function() &#123;&#125;();1 &gt; function() &#123;&#125;(); 两个整数交换数值1234567var a = 20, b = 30;a ^= b;b ^= a;a ^= b;a; // 30b; // 20 数字字符转数字12var a = '1';+a; // 1 最短的代码实现数组去重1[...new Set([1, "1", 2, 1, 1, 3])]; // [1, "1", 2, 3] 用最短的代码实现一个长度为m(6)且值都n(8)的数组1Array(6).fill(8); // [8, 8, 8, 8, 8, 8] 将argruments对象转换成数组1234567var argArray = Array.prototype.slice.call(arguments);// ES6：var argArray = Array.from(arguments)// orvar argArray = [...arguments]; 获取日期时间缀12345678// 获取指定时间的时间缀new Date().getTime();(new Date()).getTime();(new Date).getTime();// 获取当前的时间缀Date.now();// 日期显示转换为数字+new Date(); 使用~x.indexOf(&#39;y&#39;)来简化x.indexOf(&#39;y&#39;) &gt; -12345678var str = 'hello world';if (str.indexOf('lo') &gt; -1) &#123; // ...&#125;if (~str.indexOf('lo')) &#123; // ...&#125; parseInt() or Number()两者的差别之处在于解析和转换两者之间的理解。 解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否者会失败并返回NaN。 12345678var a = '520';var b = '520px';Number(a); // 520parseInt(a); // 520Number(b); // NaNparseInt(b); // 520 parseInt方法第二个参数用于指定转换的基数，ES5默认为10进制。1234parseInt('10', 2); // 2parseInt('10', 8); // 8parseInt('10', 10); // 10parseInt('10', 16); // 16 对于网上parseInt(0.0000008)的结果为什么为8，原因在于0.0000008转换成字符为”8e-7”，然后根据parseInt的解析规则自然得到”8”这个结果。 +拼接操作，+x or String(x)？+运算符可用于数字加法，同时也可以用于字符串拼接。如果+的其中一个操作符是字符串(或者通过 隐式强制转换可以得到字符串)，则执行字符串拼接；否者执行数字加法。 需要注意的时对于数组而言，不能通过valueOf()方法得到简单基本类型值，于是转而调用toString()方法。1[1,2] + [3, 4]; // "1,23,4" 对于对象同样会先调用valueOf()方法，然后通过toString()方法返回对象的字符串表示。 12var a = &#123;&#125;;a + 123; // "[object Object]123" 对于a + &quot;&quot;隐式转换和String(a)显示转换有一个细微的差别：a + &#39;&#39;会对a调用valueOf()方法，而String()直接调用toString()方法。大多数情况下我们不会考虑这个问题，除非真遇到。 1234567var a = &#123; valueOf: function() &#123; return 42; &#125;, toString: function() &#123; return 4; &#125;&#125;a + ''; // 42String(a); // 4 判断对象的实例1234567891011121314151617181920212223242526// 方法一: ES3function Person(name, age) &#123; if (!(this instanceof Person)) &#123; return new Person(name, age); &#125; this.name = name; this.age = age;&#125;// 方法二: ES5function Person(name, age) &#123; var self = this instanceof Person ? this : Object.create(Person.prototype); self.name = name; self.age = age; return self;&#125;// 方法三：ES6function Person(name, age) &#123; if (!new.target) &#123; throw 'Peron must called with new'; &#125; this.name = name; this.age = age;&#125; 数据安全类型检查1234567891011121314// 对象function isObject(value) &#123; return Object.prototype.toString.call(value).slice(8, -1) === 'Object'';&#125;// 数组function isArray(value) &#123; return Object.prototype.toString.call(value).slice(8, -1) === 'Array';&#125;// 函数function isFunction(value) &#123; return Object.prototype.toString.call(value).slice(8, -1) === 'Function';&#125; 让数字的字面值看起来像对象123452.toString(); // Uncaught SyntaxError: Invalid or unexpected token2..toString(); // 第二个点号可以正常解析2 .toString(); // 注意点号前面的空格(2).toString(); // 2先被计算 对象可计算属性名(仅在ES6中)12345678var suffix = ' name';var person = &#123; ['first' + suffix]: 'Nicholas', ['last' + suffix]: 'Zakas'&#125;person['first name']; // "Nicholas"person['last name']; // "Zakas" 数字四舍五入12345678// v: 值，p: 精度function (v, p) &#123; p = Math.pow(10, p &gt;&gt;&gt; 31 ? 0 : p | 0) v *= p; return (v + 0.5 + (v &gt;&gt; 31) | 0) / p&#125;round(123.45353, 2); // 123.45 在浏览器中根据url下载文件12345678910111213141516171819202122232425262728function download(url) &#123; var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') &gt; -1; var isSafari = navigator.userAgent.toLowerCase().indexOf('safari') &gt; -1; if (isChrome || isSafari) &#123; var link = document.createElement('a'); link.href = url; if (link.download !== undefined) &#123; var fileName = url.substring(url.lastIndexOf('/') + 1, url.length); link.download = fileName; &#125; if (document.createEvent) &#123; var e = document.createEvent('MouseEvents'); e.initEvent('click', true, true); link.dispatchEvent(e); return true; &#125; &#125; if (url.indexOf('?') === -1) &#123; url += '?download'; &#125; window.open(url, '_self'); return true;&#125; 快速生成UUID1234567891011function uuid() &#123; var d = new Date().getTime(); var uuid = 'xxxxxxxxxxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random() * 16) % 16 | 0; d = Math.floor(d / 16); return (c == 'x' ? r : (r &amp; 0x3 | 0x8)).toString(16); &#125;); return uuid;&#125;;uuid(); // "33f7f26656cb-499b-b73e-89a921a59ba6" JavaScript浮点数精度问题12345678910function isEqual(n1, n2, epsilon) &#123; epsilon = epsilon == undefined ? 10 : epsilon; // 默认精度为10 return n1.toFixed(epsilon) === n2.toFixed(epsilon);&#125;0.1 + 0.2; // 0.30000000000000004isEqual(0.1 + 0.2, 0.3); // true0.7 + 0.1 + 99.1 + 0.1; // 99.99999999999999isEqual(0.7 + 0.1 + 99.1 + 0.1, 100); // true 格式化表单数据12345678910111213141516171819202122232425262728293031323334353637383940function formatParam(obj) &#123; var query = '', name, value, fullSubName, subName, subValue, innerObj, i; for(name in obj) &#123; value = obj[name]; if(value instanceof Array) &#123; for(i=0; i&lt;value.length; ++i) &#123; subValue = value[i]; fullSubName = name + '[' + i + ']'; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += formatParam(innerObj) + '&amp;'; &#125; &#125; else if(value instanceof Object) &#123; for(subName in value) &#123; subValue = value[subName]; fullSubName = name + '[' + subName + ']'; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += formatParam(innerObj) + '&amp;'; &#125; &#125; else if(value !== undefined &amp;&amp; value !== null) query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&amp;'; &#125; return query.length ? query.substr(0, query.length - 1) : query;&#125;var param = &#123; name: 'jenemy', likes: [0, 1, 3], memberCard: [ &#123; title: '1', id: 1 &#125;, &#123; title: '2', id: 2 &#125; ]&#125;formatParam(param); // "name=12&amp;likes%5B0%5D=0&amp;likes%5B1%5D=1&amp;likes%5B2%5D=3&amp;memberCard%5B0%5D%5Btitle%5D=1&amp;memberCard%5B0%5D%5Bid%5D=1&amp;memberCard%5B1%5D%5Btitle%5D=2&amp;memberCard%5B1%5D%5Bid%5D=2" 创建指定长度非空数组在JavaScript中可以通过new Array(3)的形式创建一个长度为3的空数组。在老的Chrome中其值为[undefined x 3]，在最新的Chrome中为[empty x 3]，即空单元数组。在老Chrome中，相当于显示使用[undefined, undefined, undefined]的方式创建长度为3的数组。 但是，两者在调用map()方法的结果是明显不同的 12345var a = new Array(3);var b = [undefined, undefined, undefined];a.map((v, i) =&gt; i); // [empty × 3]b.map((v, i) =&gt; i); // [0, 1, 2] 多数情况我们期望创建的是包含undefined值的指定长度的空数组，可以通过下面这种方法来达到目的： 1234var a = Array.apply(null, &#123; length: 3 &#125;);a; // [undefined, undefined, undefined]a.map((v, i) =&gt; i); // [0, 1, 2] 总之，尽量不要创建和使用空单元数组。 debounce方法debounce()方法用来延迟执行函数。12345678910111213141516171819var debounce = function (func, threshold, execAsap) &#123; var timeout; return function debounced() &#123; var obj = this, args = arguments; function delayed() &#123; if (!execAsap) func.apply(obj, args); timeout = null; &#125;; if (timeout) clearTimeout(timeout); else if (execAsap) func.apply(obj, args); timeout = setTimeout(delayed, threshold || 100); &#125;;&#125; 判断客户端123456789101112131415161718192021222324var browser = &#123; v: (function() &#123; var u = navigator.userAgent, app = navigator.appVersion, p = navigator.platform; return &#123; trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad weixin: u.indexOf('MicroMessenger') &gt; -1, //是否微信 webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部 UCB: u.match(/UCBrowser/i) == "UCBrowser", QQB: u.match(/MQQBrowser/i) == "MQQBrowser", win: p.indexOf('Win') &gt; -1, //判断是否是WIN操作系统 mac: p.indexOf('Mac') &gt; -1 //判断是否是Mac操作系统 &#125;; &#125;)()&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[用图标和示例解释Await和Async]]></title>
    <url>%2Fblog%2F2018%2F08%2F18%2F%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8AAwait%E5%92%8CAsync%2F</url>
    <content type="text"><![CDATA[简介JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。 本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。 在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。 Promises在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉Java 的 Future、C# 的 Task, 你会发现 promise 跟它们很像。 Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。 为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库： 1var rp = require('request-promise'); 现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求： 1const promise = rp('http://example.com/') 我们现在来看个例子：123456console.log('Starting Execution'); const promise = rp('http://example.com/');promise.then(result =&gt; console.log(result)); console.log("Can't know if promise has finished yet..."); 我们在第3行创建了一个 promise 对象，在第4行给它加了个回调函数。Promise 是异步的，所以当执行到第6行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。 直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。 下图描述了本例的计算过程： Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。 通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise:123rp('http://example.com/'). then(() =&gt; console.log('Success')). catch(e =&gt; console.log(`Failed: $&#123;e&#125;`)) 最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise:123456789101112const success = Promise.resolve('Resolved');// 打印 "Successful result: Resolved"success. then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)). catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`)) const fail = Promise.reject('Err');// 打印 "Failed with: Err"fail. then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)). catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`)) 想要更详细的 promise 教程，可以参考这篇文章。 问题来了——组合 promise只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。 例如，假设我们需要编程解决如下需求： 创建 HTTP 请求，等待请求结束并打印出结果； 再创建两个并行 HTTP 请求； 等这两个请求结束后，打印出它们的结果。 下面这段代码示范了如何解决此问题：123456789101112131415// 第一次调用const call1Promise = rp('http://example.com/'); call1Promise.then(result1 =&gt; &#123; // 第一个请求完成后会执行 console.log(result1); const call2Promise = rp('http://example.com/'); const call3Promise = rp('http://example.com/'); return Promise.all([call2Promise, call3Promise]);&#125;).then(arr =&gt; &#123; // 两个 promise 都结束后会执行 console.log(arr[0]); console.log(arr[1]);&#125;) 我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16行）。 下图描述了这一计算流程： Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。 对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。 Async 方法Async 是定义返回 promise 对象函数的快捷方法。 例如，下面这两种定义是等价的：12345678function f() &#123; return Promise.resolve('TEST');&#125; // asyncF 和 f 是等价的async function asyncF() &#123; return 'TEST';&#125; 类似地，抛出异常的 async 方法等价于返回拒绝 promise 的方法：12345678function f() &#123; return Promise.reject('Error');&#125; // asyncF 和 f 是等价的async function asyncF() &#123; throw 'Error';&#125; Await我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。 然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？ 答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。 下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数：123456789async function f()&#123; // response 就是 promise 执行成功的值 const response = await rp('http://example.com/'); console.log(response);&#125; // 不能在 async 方法外面用 await// 需要使用 then 回调函数……f().then(() =&gt; console.log('Finished')); 现在我们来看如何解决上一节的问题：1234567891011121314151617181920212223// 将解决方法封装到 async 函数中async function solution() &#123; // 等待第一个 HTTP 请求并打印出结果 console.log(await rp('http://example.com/')); // 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行 const call2Promise = rp('http://example.com/'); // Does not wait! const call3Promise = rp('http://example.com/'); // Does not wait! // 创建完以后 —— 等待它们都执行完 const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);&#125; // 调用这一 async 函数solution().then(() =&gt; console.log('Finished')); 上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。 当然，在第一个例子（没有用 async / await）中，两个 promise会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。 这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。 实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。 我们再看看下面的例子：12345async function f() &#123; console.log('Starting F'); const result = await rp('http://example.com/'); console.log(result);&#125; 下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行： Await 的计算过程。 函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。 错误处理前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况：1234567async function f() &#123; try &#123; const promiseResult = await Promise.reject('Error'); &#125; catch (e)&#123; console.log(e); &#125;&#125; Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise:123456789101112131415161718async function f() &#123; // Throws an exception const promiseResult = await Promise.reject('Error');&#125; // Will print "Error"f(). then(() =&gt; console.log('Success')). catch(err =&gt; console.log(err)) async function g() &#123; throw "Error";&#125; // Will print "Error"g(). then(() =&gt; console.log('Success')). catch(err =&gt; console.log(err)) 结论Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise: 1234567async function fAsync() &#123; // actual return value is Promise.resolve(5) return 5;&#125; // can't call "await fAsync()". Need to use then/catchfAsync().then(r =&gt; console.log(`result is $&#123;r&#125;`)); 我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。 Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。 关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。 我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。 并发VS并行从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。]]></content>
  </entry>
</search>
